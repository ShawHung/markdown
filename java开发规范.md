## :notebook_with_decorative_cover:java开发规范

### :accept:java排版规范

+ 大括号，“{”处于行尾，“}”另起一行

+ 一行只允许一条语句

+ 判断语句和循环校验代码体加大括号

+ 单行超过100字符换行

  + 断行比上行缩进四个字符
  + 逗号后换行
  + 操作符前断行
  + 方法调用点符号与下文一起换行

+ 空行分隔

  + 两个方法之间
  + 块注释或单行注释之前
  + 一个方法内的两个逻辑段之间

+ 使用代码格式化工具只对需要格式化的代码片段格式化，不允许对整个文档格式化。

+ 类和接口中元素的布局顺序

  ```mermaid
  graph TD
  A(类的接口的文档描述) --> B(类的接口的声明)
  B(类的接口的声明) --> C(类的静态变量)
  C(类的静态变量) --> D(实例变量)
  D(实例变量) -->E(类的方法)
  ```

  + 静态变量和实例变量的顺序

    ```mermaid
    graph LR
    A(publilc)-->B(protected)
    B(protected)-->C(package)
    C(package)-->D(private)
    ```

+ 定义方法时修饰符按照顺序声明，访问修饰符放在最前面

+ 4个空格缩进，不可以使用tab字符

  + 二目三目运算符左右两边加空格

  + 保留字后面加空格

  + 逗号后加空格

  + 冒号两边加空格

  + 分号后面加空格

    

### :accept:Java注释规范

 +  关键代码必须加注释，注释占比20%以上，注释中表明功能，逻辑，参数说明等。
 +  **注释格式**：两类注释（实现注释，文档注释），四种注释风格（块注释，单行注释，尾端注释，行末注释）
    	+  行末注释“//”放在所需注释行行末或上一行
        	+  单行注释显示在一行内，和其后代码具有相同缩进层级，注释前有空行，一行写不完使用块注释
            	+  块注释可以放在文件开始处，方法前或者方法内部等，方法和功能内的块注释和其注释代码保持相同注释层级，块注释之前应该有空行。
                	+  尾端注释是极短的注释，可以与其注释代码出现在同一行，代码和注释之间保持足够的空白，大段代码中的多个短注释保持相同的缩进。
                    	+  文档注释写在类，域，构造函数，方法，字段定义之前。
+  **必须的基本注释**：
   +  接口和类的注释：class和interface之前，需添加创建者和创建日期。
   +  构造函数注释：文档注释。
   +  方法注释：文档注释。
   +  全局变量注释：单行注释，标明含义，目的，功能
   +  字段/属性注释：单行注释，注释内容左对齐
+  **必须的特殊注释：**
   +  典型的算法需要注释，自己编写的算法添加注释
   +  代码修改需要添加修改原因，修改人，修改信息等注释。
   +  循环、业务分支组成的代码中添加注释。
   +  为上层服务提供的接口添加注释，标明入参格式，返回类型等信息
+  在多层嵌套的if,for语句中，需要以尾端注释的方式表现出层次关系。
+  代码应该和注释保持同步，保证代码和注释的一致性。



### :accept:Java命名规范

+ 禁止拼音英文混合，禁止使用中文

+ 包命名全部使用小写字母，不允许出现下划线或其他符号

  + 中移在线包名：com.cmos.项目缩写

+ 类/接口命名采用UpperCamelCase风格，大小写混合，每个单词首字母大写。除去（DO/BO/DTO/VO/AO/PO/UID）等。

+ 方法采用大小写混合写法，首字母小写。设置和查询属性使用setter和getter方法。

+ 变量首字母小写，其他单词首字母大写。

  + 变量需要有实际含义，禁止使用拼音缩写，逻辑变量避免使用flag,is等。
  + 除静态变量外，其他变量不可使用"_"分割。
  + 编号变量在变量后添加"No"后缀，如`userNo`。
  + 静态常量(变量使用final.static修饰时)名字必须大写。

+ 定义数组，将类型和中括号紧挨相连表示数字，将"[]"放在变量前。

  ```java
  //定义整型数组User[]  users
  
  User[] users = new Users[10];
  ```

+ 文件后缀命名规范：

  | Java源文件     | .java       |
  | -------------- | ----------- |
  | Java字节码文件 | .class      |
  | Xml配置文件    | .xml        |
  | 资源文件       | .properties |
  | 日志文件       | .log        |
  | Java包文件     | .jar        |
  | Java上线包     | .war        |

+ 接口命名使用"I"开头，接口的实现类使用"Impl"结尾。

  + 服务类接口使用"I"开头，使用"Service"结尾，其实现类为去"I"之后添加ServiceImpl;Dao接口使用"I"开头，"Dao"结尾，其实现类为去"I"之后添加"DaoImpl"。

    ```java
    服务接口实例:IUserService
    实现类:UserServiceImpl
    Dao接口示例:IUserDao
    实现类:UserDaoImpl
    ```

+ 声明抽象类使用Abstract前缀。

+ 声明实现类或编写继承类，缺省的实现类需要使用"Default"前缀。





### :accept:Java编程规范

#### :one:代码格式规范

+ 方法代码函数不超过100行，长的方法拆分为私有函数。整个代码不超过2000行。
+ 方法编写符合单一职责原则。
+ 导入类时只导入需要的类，避免使用`import XXXX.XXX.*`
+ 充分使用finally，保证所有的资源都被释放。
+ 类中的全局变量、静态变量声明在类的开始位置。



#### :two:面向对象编码规范

+ 处理hashCode和equals的处理：
  + 只要重写equals，就必须重写hashCode。
  + Set存储的对象存储的对象必须重写这两个方法。
  + 自定义对象作为Map的键，必须重写hashCode和equals
+ 用类名来访问类的静态变量或静态方法，避免使用类的对象引用访问。
+ 复写方法必须加@Override注解。
+ 外部正在调用或者二方库依赖的接口，不允许修改方法签名，接口过时加@Deprecated注解，说明采用的新接口或新服务。
+ 不使用过时的方法和类。
+ 所有的相同类型的包装类对象之间值得比较，全部使用equals比较。
+ 序列化类新增属性时，不要修改serialVersionUID字段。
+ 不能在构造方法里加入任何业务逻辑，初始化逻辑放在init方法中。
+ POJO类必须重写toString()方法。
  + 继承另一个POJO类，要在前面加上super.toString()
  + 方法抛出异常，直接调用POJO的toString()方法打印出属性值以便排查问题。



#### :three:集合处理规范

+ hashCode和equals的处理同上。
+ 使用ArrayList的subList返回ArrayList的内部类SubList，并不是ArrayList而是其一个视图，对于SubList的所有操作最终会反映到原列表上。
  + subList结果不可强转为ArrayList，否则抛出ClassCastException异常。
  + 对原集合元素的增加和删除均会导致子列表遍历，增加，删除产生ConcurrentModificationException异常。
+ 使用工具类Array.asList()把数组转换成集合时，不能使用其修改集合的相关方法。其add/remove/clear方法会抛出UnsupportedOperationException异常。
+ 不可以在foreach循环里进行元素的remove/add操作，remove元素要使用Iterator方式，并发操作需要给Iterator对象加锁。
+ JDK7及以上，Comparator实现类需要满足：
  + x,y比较结果和y,x比较结果相反。
  + x>y,y>z,则x>z
  + x=y,则x,z和y,z的比较结果相同。
+ 集合泛型定义时，在JDK7及以上，使用菱形泛型(diamond)语法或全省略来指代前边已经指定的类型。

#### 

#### :four:并发控制规范

+ 避免过多使用synchronized关键字以减少死锁的发生。
+ 获取单例对象要保证线程安全，其中的方法也要保证线程安全。
+ 创建线程或线程池时指定有意义的线程名称。
+ 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
+ 通过ThreadPoolExecutor创建线程池而不是Executors创建。明确指定线程池参数，线程池运行规则，规避资源耗尽的风险。
+ SimpleDateFormat是线程不安全的类，一般禁止定义为static变量，如果定义为static则必须加锁或者使用DateUtils工具类。
+ 多个资源，数据库表，对象同时加锁时，要保持一致的加锁顺序，避免产生死锁。
+ 使用ScheduledExecutorService来处理多线程并行处理定时任务时，当Timer运行多个TimeTask时，其中之一未捕获异常，其他任务自动终止的问题。
+ 避免Random实例被多线程使用。
  + Random实例应该包括java.util.Random的实例或者Math.random()的方式。
+ 使用static修饰ThreadLocal解决共享对象的更新问题。





#### :five:控制逻辑规范

+ switch，每个case要么通过break/return来终止。要么通过注释标明程序执行到哪个case为止。
+ 避免在条件语句中执行方法。
+ 避免过长的boolean表达式。





#### :six:异常处理规范

+ 异常应该抛出或记录日志，禁止try-catch后不进行处理。

+ 不可以通过catch处理方式来处理RuntimeExecption。可以通过预检查的方式来避免。如NullPointerException、IndexOutOfBoundsException等。

+ 禁止使用异常进行流程控制、条件控制等逻辑控制。

+ catch时区分稳定代码和非稳定代码，对于非稳定代码catch尽可能进行区分异常类型在做对应的异常处理。

  不可以对大段代码进行try-catch。

+ try-catch放在事务代码中，catch异常后需要回滚事务要手动回滚。

+ finally块必须对资源对象，流对象进行关闭，有异常要做try-catch处理。

  + JDK7以上可以使用try-with-resources方式。

+ 防止NPE产生

  + 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。
  + 数据库的查询结果可能为null。
  + 集合里的元素isNotEmpty取出的数据元素也可能为null。
  + 远程调用返回对象时，一律要求进行空指针判断，防止NPE。
  + 对于Session中获取的数据，进行NPE检查，避免空指针。
  + 级联调用obj.getA().getB()，容易产生NPE。





#### :seven:日志打印规范

+ 应用中使用在线公司统一的日志框架cmos-logger。
+ 应用需要制定模块编码内部规范，前后端日志编码保持统一风格，具备唯一性，有没明确意义。
+ 生产代码中不可以使用System.out.print，System.error，Throwable.printStackTrace等打印调试语句。必须使用logger日志进行打印。
+ 禁止在生产环境正常运行态中开启对trace/debug级别的日志输出，有选择地输出info日志，避免大量日志占用服务器磁盘。
+ 使用日志打印异常应该包括两类信息：案发现场信息和异常堆栈信息，不处理则通过throws向上抛出。



#### :eight:提交规范

+ 禁止将本地开发环境配置信息提交到Git服务器。
+ 及时更新工作目录，避免当天调试代码隔天提交。
+ 提交代码出现冲突先看历史说明再找同事确认，禁止强行提交覆盖代码。
+ 提交代码前确保代码在本地调试后能够运行。
+ 确保Git上的版本是正确的，项目有错误时不提交。
+ Git代码提交时，对提交信息应该采用明确的标注信息：包括该需求JIRA编号+当前次提交内容说明。以空格间隔两部分内容。



### :accept:双中心编码规范

**应用双中心部署时，必须在环境变量中配置中心编码，系统编码，应用编码，实例编码等**

#### 

#### :one:中间件接入使用规范

+ 业务应用必须接入以下中间件：
  + 序列化唯一ID生成组件：cmos-sequence。
  + 数据同步组件：在双中心内实现单向或双向数据同步，中心切换后可继续提供服务。
+ 禁止在业务应用内依赖数据库主键生成策略，避免多中心数据同步出现主键冲突。
+ 业务应用内必须实现合理降级、容错处理，不完全依赖中间件，在中间件故障情况下，应用可继续提供服务。
+ 使用数据同步组件，必须从设计阶段纳入设计范围，在设计、开发、测试等多个流程输出对应设计、实现流程文档，进行评审。

#### :two:

+ 域名使用是双中心运转和切换所必须使用的，禁止在业务代码中使用IP替代，包括但不限于以下场景：
  + 数据库JDBC地址
  + 中间价如zookeeper,redis等地址
  + 依赖内部其它系统接口地址
+ 域名申请、使用，遵循在线统一规范，使用统一提交模板，进行评审。

